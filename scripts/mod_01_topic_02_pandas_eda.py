import warnings
import numpy as np
import pandas as pd
import seaborn as sns
from ydata_profiling import ProfileReport

# %%
# набір даних Planets, доступний через пакет Seaborn. містить інформацію про планети, які астрономи відкрили навколо інших зірок

planets = sns.load_dataset('planets')
planets.shape

# %%
# деякі подробиці про 1000+ позасонячних планет

planets.head()

# %%
# Як і у випадку з одновимірним масивом NumPy, для рядів Pandas агрегати повертають єдине значення:
rng = np.random.RandomState(42)
ser = pd.Series(rng.rand(5))
ser

# %%
ser.sum()

# %%
ser.mean()

# %%
# Для DataFrame за замовчуванням агрегати повертають результати в кожному стовпчику:
df = pd.DataFrame({'A': rng.rand(5),
                   'B': rng.rand(5)})
df

# %%
df.mean()

# %%
# Вказавши аргумент осі, ви можете агрегувати в межах кожного рядка
df.mean(axis='columns')

# %%
# У Pandas існує зручний метод describe(), який обчислює кілька загальних агрегатів для кожного стовпця та повертає результат. 
# Використаємо його для даних про планети, поки що відкинувши рядки з пропущеними значеннями:
planets.dropna().describe()

# корисно розуміти загальні властивості набору даних.
# Наприклад, у колонці "Рік" ми бачимо, що хоча екзопланети були відкриті ще у 1989 році, половину всіх відомих екзопланет 
# було відкрито лише у 2010 році або пізніше.

# %%
# Однак, щоб заглибитися в дані, простих агрегатів недостатньо. Наступним рівнем узагальнення даних є операція групування, 
# яка дозволяє швидко та ефективно обчислювати агрегати на підмножинах даних.

# Операції GroupBy
# Прості агрегації можуть дати уявлення про набір даних, але часто ми хотіли б об'єднати їх умовно за якоюсь міткою або індексом: це реалізовано в операції GroupBy.
# Канонічний приклад цієї операції "розділити-застосувати-об'єднати" (де "застосувати" — це підсумкове агрегування):

# На етапі розділення (Split) DataFrame розбивається на групи відповідно до визначеного ключа. 
#   Це дозволяє логічно групувати дані за певним параметром чи критерієм.
# Далі, на етапі застосування (Apply), у межах кожної групи застосовуються різні обчислення або фільтрації. 
#   Це може бути агрегація, перетворення чи інші операції, які необхідні для обробки конкретної підгрупи даних.
# Крок Combine об'єднує результати цих операцій у вихідний масив, забезпечуючи компактний та організований набір даних.
# GroupBy може автоматично виконувати проміжні розбиття та обчислення, спрощуючи процес для користувача.    

df = pd.DataFrame({'key': ['A', 'B', 'C', 'A', 'B', 'C'],
                   'data': range(6)}, columns=['key', 'data'])
df

# %%
df.groupby('key')

# %%
# Групуємо й застосовуємо агрегат
df.groupby('key').sum()
#  Об'єкт GroupBy є дуже гнучкою абстракцією. Багато в чому можна поводитися з ним так, ніби це колекція DataFrame, і він виконує складні речі під капотом.
# %%
planets.head
# %%
# Тут, наприклад, ми вибрали певну групу Series з вихідної групи DataFrame за посиланням на назву її стовпця.
planets.groupby('method')['orbital_period'].median()

# %%
# Можемо використовувати метод describe() DataFrames для виконання набору агрегацій, які описують кожну групу в даних:
planets.groupby('method')['year'].describe()
# Подивившись на цю таблицю, ми можемо краще зрозуміти дані.
# Наприклад, переважна більшість планет була відкрита за допомогою методів радіальної швидкості і транзиту, хоча останній став 
# поширеним (завдяки новим, більш точним телескопам) лише в останнє десятиліття. Найновішим методом, імовірно, є метод варіації 
# часу транзиту і метод модуляції яскравості орбіти, які не використовувалися для відкриття нової планети до 2011 року.

# %%
# Зробимо ще декілька тренувальних агрегацій на синтетичному датасеті. Спочатку генеруємо сам датасет:
rng = np.random.RandomState(0)
df = pd.DataFrame({'key': ['A', 'B', 'C', 'A', 'B', 'C'],
                   'data1': range(6),
                   'data2': rng.randint(0, 10, 6)},
                  columns=['key', 'data1', 'data2'])
df

# %%
# Ми вже знайомі з агрегаціями GroupBy за допомогою функцій sum(), median() тощо, але метод agg() забезпечує ще більшу гнучкість. 
# Він може приймати рядок, функцію або їх список і обчислювати всі агрегати одночасно:
df.groupby('key').agg(['min', 'median', 'max'])

# %%
# Ще одним корисним патерном є передача словника, що відображає назви стовпців та операції, які будуть застосовані до цього стовпця:
df.groupby('key').agg({'data1': 'min', 'data2': 'max'})

# %%
def center(x):
    return x - x.mean()

df.groupby('key').transform(center)

# %%
def norm_by_data2(x):
    # x is a DataFrame of group values
    x['data1'] /= x['data2'].sum()
    return x

df.groupby('key').apply(norm_by_data2, include_groups=False)

# %%
# Як приклад, у кількох рядках коду Python ми можемо об'єднати все це разом і порахувати відкриті планети за методами і за десятиліттями:

decade = 10 * (planets['year'] // 10)
decade = decade.astype(str) + 's'
decade.name = 'decade'
    # Групування даних за method та decade, підсумовування number
planets.groupby(['method', decade])['number'].sum().unstack().fillna(0)

# Ми одразу отримуємо приблизне розуміння того, коли і як були відкриті планети за останні кілька десятиліть!

# %% 
# Завантажимо базу даних пасажирів Титаніка, 
titanic = sns.load_dataset('titanic')
titanic.head()

# %%
# Щоб дізнатися про дані, використаємо зведені таблиці. Можемо почати з групування за статтю, статусом виживання або за певною комбінацією цих ознак.
titanic.groupby('sex')[['survived']].mean()
# Це одразу ж дає нам певне уявлення: загалом три з кожних чотирьох жінок на борту вижили, тоді як вижив лише один з п'яти чоловіків!

# %%
# Підемо глибше й подивитися на показник виживання за статтю і за класом. З GroupBy, ми можемо діяти приблизно так: 
# групуємо за класом і статтю, вибираємо “виживання”, застосовуємо середній агрегат, об'єднуємо отримані групи, 
# а потім розкладаємо ієрархічний індекс, щоб виявити приховану багатовимірність:

# двовимірний GroupBy
(titanic
 .groupby(['sex', 'class'],
          observed=True)['survived']
 .mean()
 .unstack())
# Як і слід було очікувати, градієнт виживання був на користь як жінок, так і вищих класів. 
# Жінки першого класу вижили майже всі, тоді як серед чоловіків третього класу вижив лише один з десяти.

# %%
# еквівалент попередньої операції. Pandas містить зручну процедуру pivot_table, яка лаконічно обробляє цей тип багатовимірної агрегації.
titanic.pivot_table('survived', index='sex', columns='class', observed=True)

# %%
# Групування у зведених таблицях можна вказати на декількох рівнях і за допомогою різних параметрів. 
# Наприклад, нам може бути цікаво розглянути вік як третій вимір. Ми відділимо вік за допомогою функції pd.cut:
# вік як третій вимір
age = pd.cut(titanic['age'], [0, 18, 80])

titanic.pivot_table('survived', ['sex', age], 'class', observed=True)

# %%
titanic['fare']

# %%
# Можемо застосувати ту ж саму стратегію при роботі зі стовпчиками: додамо інформацію про сплачену вартість проїзду за допомогою pd.qcut, щоб автоматично обчислити квантилі:
fare = pd.qcut(titanic['fare'], 2)

titanic.pivot_table('survived', ['sex', age], [fare, 'class'],  observed=True)

# Квантиль у статистиці — це значення, яке розділяє впорядкований набір даних на певну частину або відсоток.
# У наведеному прикладі набір даних розбито на дві групи, що відповідають кількості спостережень у датасеті. 
# Отримано поріг за вартістю у 14,45$: 50% пасажирів купили квитки вартістю до 14.45$, інші — більше 14,45$.

# Подібні маніпуляції з даними допомагають нам краще зрозуміти природу і явища, які описує датасет.

  # %%
# ydata-profiling дозволяє отримати детальний інтерактивний звіт про датасет. (conda install ydata-profiling)
#  -для початківців (всебічне уявлення про набір даних без необхідності писати багато коду).
#  -Досвідчені використовують для швидкого аудиту даних та виявлення в них потенційних проблем.

# Створюємо та зберігаємо інтерактивний звіт про набір даних пасажирів Титаніка, який надасть повноцінне первинне уявлення про датасет, 
# допомагаючи легко і швидко аналізувати та розуміти його основні статистичні характеристики. Відкриємо збережений файл у браузері.

with warnings.catch_warnings():
    warnings.simplefilter('ignore')

    report = ProfileReport(
        titanic,
        title='Titanic')

    report.to_file('../derived/mod_01_topic_02_titanic_report.html')
